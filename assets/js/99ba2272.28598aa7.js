"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[505],{4108:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"managers","title":"Managers","description":"Tether will create a Manager class for each table that is defined in the","source":"@site/docs/managers.md","sourceDirName":".","slug":"/managers","permalink":"/flutter_tether/managers","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Select Builders","permalink":"/flutter_tether/select_builders"},"next":{"title":"Full Text Search","permalink":"/flutter_tether/full_text_search"}}');var o=t(4848),r=t(8453);const l={sidebar_position:5},s="Managers",i={},d=[{value:"Accessing Managers",id:"accessing-managers",level:2},{value:"TetherClientReturn",id:"tetherclientreturn",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Database Client API",id:"database-client-api",level:3},{value:"Count Information and Pagination",id:"count-information-and-pagination",level:4},{value:"Streaming Data",id:"streaming-data",level:4},{value:"Local or Remote Fetching",id:"local-or-remote-fetching",level:4},{value:"Relationships",id:"relationships",level:4},{value:"RPC Calls",id:"rpc-calls",level:3},{value:"Realtime Client API",id:"realtime-client-api",level:2},{value:"Error Handling Best Practices",id:"error-handling-best-practices",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"managers",children:"Managers"})}),"\n",(0,o.jsxs)(n.p,{children:["Tether will create a ",(0,o.jsx)(n.code,{children:"Manager"})," class for each table that is defined in the\nschema. The Manager is in-essence a wrapper around the Supabase client API and\noperates very much like the Supabase client API. It will automatically handle\ncaching data fetched from the remote database as well as automatically handle\noptimistic updates for inserts, updates, and deletes."]}),"\n",(0,o.jsxs)(n.p,{children:["All manager operations now return ",(0,o.jsx)(n.code,{children:"TetherClientReturn<TModel>"})," objects that\ninclude both data and metadata like count information."]}),"\n",(0,o.jsx)(n.h2,{id:"accessing-managers",children:"Accessing Managers"}),"\n",(0,o.jsxs)(n.p,{children:["After generation managers will be available in the ",(0,o.jsx)(n.code,{children:"lib/database/managers"}),"\ndirectory."]}),"\n",(0,o.jsx)(n.p,{children:"The intended way to use the manager is via Riverpod, but you can also use it\ndirectly with another state management solution or even without any state\nmanagement."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"// With Riverpod\nfinal booksManager = ref.watch(booksManagerProvider);\n\n// Without Riverpod - you have to pass some options in to the constructor, but you could then use it via GetIt or any other DI solution.\nfinal bookManager = BooksManager(\n    localDb: database.db, // The local SQLite database instance\n    client: Supabase.instance.client, // The Supabase client instance\n    tableSchemas: globalSupabaseSchema, // The global schema for the tables\n    fromJsonFactory: (json) => BookModel.fromJson(json), // Factory to convert Supabase JSON to the model.\n    fromSqliteFactory: (json) => BookModel.fromSqlite(json), // Factory to convert SQLite JSON to the model.\n  );\n"})}),"\n",(0,o.jsx)(n.h2,{id:"tetherclientreturn",children:"TetherClientReturn"}),"\n",(0,o.jsxs)(n.p,{children:["All manager operations return a ",(0,o.jsx)(n.code,{children:"TetherClientReturn<TModel>"})," object with the\nfollowing properties:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"data"}),": ",(0,o.jsx)(n.code,{children:"List<TModel>"})," - The actual model instances"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"count"}),": ",(0,o.jsx)(n.code,{children:"int?"})," - Total count of records matching the query (when available\nfrom remote)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"error"}),": ",(0,o.jsx)(n.code,{children:"String?"})," - Error message if an error occurred"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"hasError"}),": ",(0,o.jsx)(n.code,{children:"bool"})," - Convenience getter for checking if an error occurred"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"single"}),": ",(0,o.jsx)(n.code,{children:"TModel"})," - Convenience getter for getting the first item (throws if\nempty)"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"final result = await booksManager.query.select(BooksSelectBuilder().select());\n\n// Access the data\nfinal books = result.data; // List<BookModel>\nfinal totalCount = result.count; // int? - total matching records\nfinal hasError = result.hasError; // bool\n\n// Handle errors\nif (result.hasError) {\n  print('Error: ${result.error}');\n  return;\n}\n\n// Get single item (throws if no data)\ntry {\n  final book = result.single; // First BookModel\n} catch (e) {\n  print('No books found');\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,o.jsx)(n.p,{children:"The Tether Manager API is almost identical to the Supabase client API, so if you\nare familiar with the Supabase client API, you will feel right at home. It wraps\nthe following APIs:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Database client API","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"RPC is supported, but see notes below."}),"\n",(0,o.jsx)(n.li,{children:"Full-text search is supported, but see notes below."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.li,{children:"Realtime client API"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"database-client-api",children:"Database Client API"}),"\n",(0,o.jsx)(n.p,{children:"This will be the most commonly used API. It allows you to fetch data from\nSupabase, cache it locally, and mutate it. You will use the same methods to also\nfetch data from the local SQLite database."}),"\n",(0,o.jsxs)(n.p,{children:["You can use the ",(0,o.jsx)(n.code,{children:"query()"})," method to create a query builder for the table, and\nthen use the ",(0,o.jsx)(n.code,{children:"select()"}),", ",(0,o.jsx)(n.code,{children:"insert()"}),", ",(0,o.jsx)(n.code,{children:"update()"}),", and ",(0,o.jsx)(n.code,{children:"delete()"}),", filter and\ntransform methods to build your query."]}),"\n",(0,o.jsx)(n.p,{children:"There are a few key differences to the Supabase client API:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"select()"})," method does not take a string, but rather a ",(0,o.jsx)(n.code,{children:"SelectBuilder"}),"\ninstance that allows you to build the select statement in a Tether manner."]}),"\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"insert()"}),", ",(0,o.jsx)(n.code,{children:"update()"}),", ",(0,o.jsx)(n.code,{children:"upsert()"})," and ",(0,o.jsx)(n.code,{children:"delete()"})," methods take a list of\nmodels (BookModel, AuthorModel, etc.) rather than a map of data. This allows\nyou to work with the models directly and ensures type safety."]}),"\n",(0,o.jsxs)(n.li,{children:["Filters and Transforms, like ",(0,o.jsx)(n.code,{children:"eq()"}),", ",(0,o.jsx)(n.code,{children:"like()"}),", ",(0,o.jsx)(n.code,{children:"order()"}),", etc., accept a\n",(0,o.jsx)(n.code,{children:"TetherColumn"})," instance rather than a string. This allows you to use the\ngenerated columns from the models directly, ensuring type safety and avoiding\ntypos."]}),"\n",(0,o.jsxs)(n.li,{children:["On inserts and updates you do not need to pass the ending ",(0,o.jsx)(n.code,{children:".select()"})," to get\nreturning data like you would with the Supabase client API. Tether will\nautomatically return the inserted or updated data as models."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsxs)(n.strong,{children:["All operations return ",(0,o.jsx)(n.code,{children:"TetherClientReturn<TModel>"})]})," which includes both\ndata and metadata."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Some examples of how to use the Manager API:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"final booksManager = ref.watch(booksManagerProvider);\n\n// Fetch all books with count information\nfinal result = await booksManager.query.select(BooksSelectBuilder().select());\nfinal books = result.data; // List<BookModel>\nfinal totalCount = result.count; // int? - total books in database\n\n// Fetch a single book by ID\nfinal result = await booksManager.query.select(BooksSelectBuilder().select())\n    .eq(BooksColumn.id, 'some-book-id')\n    .limit(1);\n\nif (result.hasError) {\n  print('Error: ${result.error}');\n} else if (result.data.isNotEmpty) {\n  final book = result.single; // Get the first (and only) book\n  print('Found book: ${book.title}');\n}\n\n// Insert a new book\nfinal newBook = BookModel(\n  id: 'new-book-id',\n  title: 'New Book',\n  authorId: 'author-id',\n  // other fields...\n);\nfinal insertResult = await booksManager.query.insert([newBook]);\nfinal insertedBooks = insertResult.data; // List<BookModel> with the inserted book\n\n// Update a book\nfinal updatedBook = BookModel(\n  id: 'some-book-id',\n  title: 'Updated Book Title',\n  // other fields...\n); // You will typically want to pass in a mutated version of the whole model, not just the fields you want to update.\nfinal updateResult = await booksManager.query.update([updatedBook])\n    .eq(BooksColumn.id, 'some-book-id');\nfinal updatedBooks = updateResult.data; // List<BookModel> with updated book\n\n// Delete a book\nfinal deleteResult = await booksManager.query.delete()\n    .eq(BooksColumn.id, 'some-book-id');\n// deleteResult.data will be empty for delete operations\nprint('Delete successful: ${!deleteResult.hasError}');\n"})}),"\n",(0,o.jsx)(n.h4,{id:"count-information-and-pagination",children:"Count Information and Pagination"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"count"})," field in ",(0,o.jsx)(n.code,{children:"TetherClientReturn"})," provides valuable information for\npagination and UI:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"// Get books with pagination info\nfinal result = await booksManager.query.select(BooksSelectBuilder().select())\n    .order(BooksColumn.createdAt, ascending: false)\n    .limit(20);\n\nfinal books = result.data;\nfinal totalAvailable = result.count; // Total books matching the query\n\nprint('Showing ${books.length} of ${totalAvailable ?? 'unknown'} books');\n\n// Use count for pagination decisions\nfinal hasMorePages = totalAvailable != null && books.length < totalAvailable;\nif (hasMorePages) {\n  print('More books available');\n}\n"})}),"\n",(0,o.jsx)(n.h4,{id:"streaming-data",children:"Streaming Data"}),"\n",(0,o.jsxs)(n.p,{children:["You can use the same manager to create a ",(0,o.jsx)(n.code,{children:"Stream"})," of your data by using\n",(0,o.jsx)(n.code,{children:"asStream()"})," instead of ",(0,o.jsx)(n.code,{children:"await"})," on the query. This will return a\n",(0,o.jsx)(n.code,{children:"Stream<TetherClientReturn<TModel>>"})," that you can listen to for changes from the\nlocal database. On initialization of the stream it will also fetch data from the\nremote database and cache it locally."]}),"\n",(0,o.jsx)(n.p,{children:"Best practice is to define your streams in a Riverpod provider so that you can\neasily listen to them in your widgets. This also allows you an easy way to pass\nin options to the manager, such as listening to a specific item based on id."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"// Watch a single book by ID\nfinal bookProvider = StreamProvider.autoDispose.family<TetherClientReturn<BookModel>, String>((ref, bookId) {\n  final booksManager = ref.watch(booksManagerProvider);\n  // Fetch a single book by ID and listen for changes\n  return booksManager.query.select(BooksSelectBuilder().select())\n      .eq(BooksColumn.id, bookId)\n      .limit(1)\n      .asStream(); // Returns Stream<TetherClientReturn<BookModel>>\n});\n\n// In your widget\nclass BookWidget extends ConsumerWidget {\n  final String bookId;\n\n  BookWidget({required this.bookId});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final bookAsyncValue = ref.watch(bookProvider(bookId));\n\n    return bookAsyncValue.when(\n      data: (result) {\n        if (result.hasError) {\n          return Text('Error: ${result.error}');\n        }\n        \n        if (result.data.isEmpty) {\n          return Text('Book not found');\n        }\n        \n        final book = result.single;\n        return Column(\n          children: [\n            Text('Book title: ${book.title}'),\n            if (result.count != null)\n              Text('Total books: ${result.count}'),\n          ],\n        );\n      },\n      loading: () => CircularProgressIndicator(),\n      error: (error, stack) => Text('Stream error: $error'),\n    );\n  }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"For a simpler approach when you only need the data and don't care about count or\nerrors in the stream:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"// Extract just the data from the stream\nfinal bookDataProvider = StreamProvider.autoDispose.family<List<BookModel>, String>((ref, bookId) {\n  final booksManager = ref.watch(booksManagerProvider);\n  return booksManager.query.select(BooksSelectBuilder().select())\n      .eq(BooksColumn.id, bookId)\n      .limit(1)\n      .asStream()\n      .map((result) => result.data); // Extract just the data\n});\n\n// Simpler widget usage\nclass BookWidget extends ConsumerWidget {\n  final String bookId;\n\n  BookWidget({required this.bookId});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final bookAsyncValue = ref.watch(bookDataProvider(bookId));\n\n    return bookAsyncValue.when(\n      data: (books) {\n        if (books.isEmpty) return Text('Book not found');\n        final book = books.first;\n        return Text('Book title: ${book.title}');\n      },\n      loading: () => CircularProgressIndicator(),\n      error: (error, stack) => Text('Error: $error'),\n    );\n  }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"As all the mutations (insert, update, delete) are automatically optimistically\nupdated, you can listen to the stream and get real-time updates from the local\ndatabase without having to worry about the state of the remote database."}),"\n",(0,o.jsx)(n.h4,{id:"local-or-remote-fetching",children:"Local or Remote Fetching"}),"\n",(0,o.jsxs)(n.p,{children:["You can use the ",(0,o.jsx)(n.code,{children:"localOnly()"})," and ",(0,o.jsx)(n.code,{children:"remoteOnly()"})," methods to tell the manager to\nonly fetch data from the local SQLite database or the remote Supabase database,\nrespectively. This is useful when you want to ensure you are only working with\nthe local data or when you want to bypass the local cache and fetch fresh data\nfrom the remote database."]}),"\n",(0,o.jsx)(n.p,{children:"Note: All remote queries will automatically cache the data locally."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"final booksManager = ref.watch(booksManagerProvider);\n\n// Fetch all books from the remote database only - useful if you are refreshing data you are watching via a Stream.\nfinal remoteResult = await booksManager.query\n    .select(BooksSelectBuilder().select())\n    .remoteOnly();\n\nfinal remoteBooks = remoteResult.data;\nfinal totalRemoteCount = remoteResult.count; // Available when fetching from remote\n\n// Fetch from local only (count will be based on local data)\nfinal localResult = await booksManager.query\n    .select(BooksSelectBuilder().select())\n    .localOnly();\n\nfinal localBooks = localResult.data;\nfinal localCount = localResult.count; // Count of local data\n"})}),"\n",(0,o.jsx)(n.h4,{id:"relationships",children:"Relationships"}),"\n",(0,o.jsxs)(n.p,{children:["Managers are smart and will automatically handle relationships, fetching and\ncaching the data for all the related items. Just pass in a SelectBuilder\ninstance to the ",(0,o.jsx)(n.code,{children:"select()"})," method and use the ",(0,o.jsx)(n.code,{children:"with*"})," methods to include related\nitems in the query."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"final booksManager = ref.watch(booksManagerProvider);\n\n// Fetch all books with their authors\nfinal result = await booksManager.query\n    .select(\n        BooksSelectBuilder().select()\n        .withAuthor(\n            AuthorsSelectBuilder().select()\n            ),\n        )\n    .eq(BooksColumn.id, 'some-book-id');\n\nfinal booksWithAuthors = result.data;\nfinal count = result.count;\n"})}),"\n",(0,o.jsx)(n.p,{children:"You can also query a table by columns on a related table. For example, if you\nwant to fetch all books by a specific author, you can do it like this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"final booksManager = ref.watch(booksManagerProvider);\n\n// Fetch all books by a specific author\nfinal result = await booksManager.query\n    .select(BooksSelectBuilder().select())\n    .withAuthor(\n        AuthorsSelectBuilder().select()\n    ).eq(AuthorsColumn.name, 'Author Name');\n\nfinal booksByAuthor = result.data;\n"})}),"\n",(0,o.jsx)(n.h3,{id:"rpc-calls",children:"RPC Calls"}),"\n",(0,o.jsxs)(n.p,{children:["Tether supports calling Remote Procedure Calls (RPC) defined in your Supabase\nproject. RPC calls also return ",(0,o.jsx)(n.code,{children:"TetherClientReturn<TModel>"})," objects. There are a\nfew things to note to make this work:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"RPCs are related to the table the Manager is for."}),"\n",(0,o.jsxs)(n.li,{children:["Because of this your stored procedure will need to return an Array of JSON\nobjects with columns that match that table in the database. This should look\nthe same as what the Supabase API returns for a table query.","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["For example, if you have a ",(0,o.jsx)(n.code,{children:"books"})," table, your RPC should return an array of\nobjects with the same structure as the ",(0,o.jsx)(n.code,{children:"books"})," table."]}),"\n",(0,o.jsx)(n.li,{children:"You can also return data from related tables, but you will need to make sure\nit conforms to the structure that a Tether model expects (look at the\nrelated Factory method in the model for the expected structure)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"final booksManager = ref.watch(booksManagerProvider);\n\n// Call an RPC that returns books\nfinal result = await booksManager.rpc('get_books_by_author', params: {\n  'author_id': 'author-id',\n}).select(BooksSelectBuilder().select());\n\nfinal books = result.data; // List<BookModel> from RPC\nfinal count = result.count; // Count if provided by RPC\n\nif (result.hasError) {\n  print('RPC Error: ${result.error}');\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"realtime-client-api",children:"Realtime Client API"}),"\n",(0,o.jsx)(n.p,{children:"Tether Managers also support the Supabase Realtime API. This allows you to\nlisten to changes in the database and get real-time updates in your app, all\ncached locally."}),"\n",(0,o.jsx)(n.p,{children:"The realtime features of the Tether Manager work similarly to the Supabase\nRealtime API, but with a few differences:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"final booksManager = ref.watch(booksManagerProvider);\n\n// Listen to changes in the books table\nfinal booksStream = booksManager\n    .realtime // Call the realtime method\n    .eq(BooksColumn.id, 'some-book-id') // Add all the filters and transforms next\n    .listen(); // Call .listen() to stream\n\n// The stream emits TetherClientReturn<BookModel> objects\nbooksStream.listen((result) {\n  if (result.hasError) {\n    print('Realtime error: ${result.error}');\n    return;\n  }\n  \n  final books = result.data;\n  print('Realtime update: ${books.length} books changed');\n});\n\n// Using an in filter\nfinal booksStream = booksManager\n    .realtime\n    .inFilter(BooksColumn.id, ['book-id-1', 'book-id-2'])\n    .listen();\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["You can use the ",(0,o.jsx)(n.code,{children:"realtime()"})," method to create a realtime query builder for the\ntable, and then use the same filters and transforms as you would with the\ndatabase client API."]}),"\n",(0,o.jsxs)(n.li,{children:["Add all the filters and transforms before calling ",(0,o.jsx)(n.code,{children:"listen()"})," (see\n",(0,o.jsx)(n.a,{href:"https://supabase.com/docs/reference/dart/stream",children:"Supabase documentation"}),")."]}),"\n",(0,o.jsx)(n.li,{children:"The Manager will automatically handle caching the data locally and return the\nTetherModels for the items that changed."}),"\n",(0,o.jsx)(n.li,{children:"By default, the realtime stream will return all changes to the table."}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsxs)(n.strong,{children:["Realtime streams emit ",(0,o.jsx)(n.code,{children:"TetherClientReturn<TModel>"})," objects"]})," with the\nchanged data."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"error-handling-best-practices",children:"Error Handling Best Practices"}),"\n",(0,o.jsxs)(n.p,{children:["With the new ",(0,o.jsx)(n.code,{children:"TetherClientReturn"})," structure, error handling is more consistent:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dart",children:"// For awaited operations\nfinal result = await booksManager.query.select(BooksSelectBuilder().select());\n\nif (result.hasError) {\n  // Handle the error\n  showErrorDialog(result.error!);\n  return;\n}\n\n// Proceed with data\nfinal books = result.data;\n\n// For streams\nfinal booksStream = booksManager.query.select(BooksSelectBuilder().select()).asStream();\n\nbooksStream.listen((result) {\n  if (result.hasError) {\n    print('Stream error: ${result.error}');\n    return;\n  }\n  \n  // Handle successful data\n  updateUI(result.data, result.count);\n});\n\n// In Riverpod providers, you can transform the stream to handle errors\nfinal safeBooksProvider = StreamProvider<List<BookModel>>((ref) {\n  final booksManager = ref.watch(booksManagerProvider);\n  return booksManager.query.select(BooksSelectBuilder().select())\n      .asStream()\n      .map((result) {\n        if (result.hasError) {\n          throw Exception(result.error);\n        }\n        return result.data;\n      });\n});\n"})}),"\n",(0,o.jsx)(n.p,{children:"This approach provides better error visibility and more consistent handling\nacross all manager operations."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>s});var a=t(6540);const o={},r=a.createContext(o);function l(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);