"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[17],{8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>s});var r=i(6540);const a={},t=r.createContext(a);function o(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),r.createElement(t.Provider,{value:n},e.children)}},8568:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"additional_features/background_manager","title":"Background Service: Background Job Processing","description":"The Background Service unit provides a robust system for executing tasks in a","source":"@site/docs/additional_features/background_manager.md","sourceDirName":"additional_features","slug":"/additional_features/background_manager","permalink":"/flutter_tether/additional_features/background_manager","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"User Preferences Manager","permalink":"/flutter_tether/additional_features/user_preferences_manager"}}');var a=i(4848),t=i(8453);const o={sidebar_position:4},s="Background Service: Background Job Processing",d={},c=[{value:"Overview",id:"overview",level:2},{value:"Setup &amp; Configuration",id:"setup--configuration",level:2},{value:"1. Enable in Configuration (<code>tether.yaml</code>)",id:"1-enable-in-configuration-tetheryaml",level:3},{value:"2. Install Dependencies",id:"2-install-dependencies",level:3},{value:"3. Generated Files (Typical)",id:"3-generated-files-typical",level:3},{value:"4. Database Schema (<code>background_service_jobs</code>)",id:"4-database-schema-background_service_jobs",level:3},{value:"Core Initialization (<code>main.dart</code>)",id:"core-initialization-maindart",level:2},{value:"1. Background Service Initialization Callback",id:"1-background-service-initialization-callback",level:3},{value:"2. Initialize <code>BackgroundService</code> in <code>main()</code>",id:"2-initialize-backgroundservice-in-main",level:3},{value:"Job Management",id:"job-management",level:2},{value:"1. Defining Job Handlers",id:"1-defining-job-handlers",level:3},{value:"2. Enqueuing Jobs from the UI",id:"2-enqueuing-jobs-from-the-ui",level:3},{value:"3. <code>BackgroundJobManager</code> (UI Isolate)",id:"3-backgroundjobmanager-ui-isolate",level:3},{value:"UI Integration &amp; Status Monitoring",id:"ui-integration--status-monitoring",level:2},{value:"Controlling the Service",id:"controlling-the-service",level:3},{value:"Displaying Job Status",id:"displaying-job-status",level:3},{value:"Using <code>ProviderContainer</code> for Non-Widget Scenarios (Main Isolate)",id:"using-providercontainer-for-non-widget-scenarios-main-isolate",level:2},{value:"Example 1: Enqueuing a Job from a Service Class (Main Isolate)",id:"example-1-enqueuing-a-job-from-a-service-class-main-isolate",level:3},{value:"Example 2: Reading Job Status for Utilities (Main Isolate)",id:"example-2-reading-job-status-for-utilities-main-isolate",level:3},{value:"Using <code>ProviderContainer</code> within a Job Handler (Background Isolate)",id:"using-providercontainer-within-a-job-handler-background-isolate",level:2},{value:"Example: Job Handler with its Own Local <code>ProviderContainer</code>",id:"example-job-handler-with-its-own-local-providercontainer",level:3},{value:"Error Handling &amp; Retries",id:"error-handling--retries",level:2},{value:"Best Practices",id:"best-practices",level:2}];function l(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"background-service-background-job-processing",children:"Background Service: Background Job Processing"})}),"\n",(0,a.jsxs)(n.p,{children:["The Background Service unit provides a robust system for executing tasks in a\nseparate isolate on mobile devices, ensuring operations can continue even when\nthe app is not in the foreground. It leverages ",(0,a.jsx)(n.code,{children:"flutter_background_service"})," and\nintegrates with a local SQLite database for persistent job queuing and\nmanagement."]}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"The system comprises several key components:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:[(0,a.jsx)(n.code,{children:"BackgroundService"})," (",(0,a.jsx)(n.code,{children:"tether_libs"}),")"]}),": The core class responsible for\ninitializing and managing the background isolate, registering job handlers,\nand enqueuing jobs."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:[(0,a.jsx)(n.code,{children:"BackgroundJobManager"})," (",(0,a.jsx)(n.code,{children:"tether_libs"}),")"]}),": A manager class for the UI isolate\nto interact with the ",(0,a.jsx)(n.code,{children:"background_service_jobs"})," SQLite table (e.g., querying\njob status, enqueuing jobs)."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Job Handlers"}),": Functions you define that execute specific tasks in the\nbackground isolate."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:[(0,a.jsx)(n.code,{children:"background_service_jobs"})," Table"]}),": An SQLite table that stores job details,\nstatus, and metadata."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Riverpod Providers"}),": For easy integration and state management in the UI."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Key features include:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Persistent Job Queue"}),": Jobs are stored in SQLite and survive app restarts."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Isolate-Based Execution"}),": Tasks run in a separate Dart isolate, preventing\nUI freezes."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Type-Safe Payloads"}),": Job data is typically handled as\n",(0,a.jsx)(n.code,{children:"Map<String, dynamic>"}),", often JSON-encoded."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Status Tracking"}),": Jobs progress through states like ",(0,a.jsx)(n.code,{children:"PENDING"}),", ",(0,a.jsx)(n.code,{children:"RUNNING"}),",\n",(0,a.jsx)(n.code,{children:"COMPLETED"}),", ",(0,a.jsx)(n.code,{children:"FAILED"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Retry Logic"}),": Automatic retries for failed jobs, configurable per job."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Priority Support"}),": Influence the order of job execution."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"setup--configuration",children:"Setup & Configuration"}),"\n",(0,a.jsxs)(n.h3,{id:"1-enable-in-configuration-tetheryaml",children:["1. Enable in Configuration (",(0,a.jsx)(n.code,{children:"tether.yaml"}),")"]}),"\n",(0,a.jsxs)(n.p,{children:["Ensure background services are enabled in your ",(0,a.jsx)(n.code,{children:"tether.yaml"})," (if applicable to\nyour Tether version for auto-generation of related components):"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"generation:\n  background_services:\n    enabled: true # Or similar configuration\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.em,{children:["Tether typically generates the ",(0,a.jsx)(n.code,{children:"background_service_jobs"})," table migration and a\nprovider for ",(0,a.jsx)(n.code,{children:"BackgroundJobManager"}),"."]})}),"\n",(0,a.jsx)(n.h3,{id:"2-install-dependencies",children:"2. Install Dependencies"}),"\n",(0,a.jsxs)(n.p,{children:["Add ",(0,a.jsx)(n.code,{children:"flutter_background_service"})," to your ",(0,a.jsx)(n.code,{children:"pubspec.yaml"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"dependencies:\n  flutter_background_service: ^5.0.5 # Use the latest compatible version\n  sqlite_async: ^0.6.0 # Ensure this is present for database operations\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-generated-files-typical",children:"3. Generated Files (Typical)"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"lib/database/providers/background_job_manager_provider.g.dart"})," (if generated\nby Tether): Provides ",(0,a.jsx)(n.code,{children:"backgroundJobManagerProvider"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Database migration for ",(0,a.jsx)(n.code,{children:"background_service_jobs"})," table."]}),"\n"]}),"\n",(0,a.jsxs)(n.h3,{id:"4-database-schema-background_service_jobs",children:["4. Database Schema (",(0,a.jsx)(n.code,{children:"background_service_jobs"}),")"]}),"\n",(0,a.jsxs)(n.p,{children:["The system relies on a table like the following (based on ",(0,a.jsx)(n.code,{children:"BackgroundJob"}),"\nmodel):"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE background_service_jobs (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    job_key TEXT NOT NULL,\n    payload TEXT,               -- JSON-encoded job parameters\n    status TEXT NOT NULL,       -- 'PENDING', 'RUNNING', 'COMPLETED', 'FAILED'\n    attempts INTEGER DEFAULT 0,\n    max_attempts INTEGER DEFAULT 3,\n    last_attempt_at TEXT,      -- ISO8601 timestamp (e.g., YYYY-MM-DDTHH:MM:SS.SSSZ)\n    last_error TEXT,\n    priority INTEGER DEFAULT 0, -- Higher numbers = higher priority\n    created_at TEXT NOT NULL,   -- ISO8601 timestamp\n    updated_at TEXT NOT NULL    -- ISO8601 timestamp\n);\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"core-initialization-maindart",children:["Core Initialization (",(0,a.jsx)(n.code,{children:"main.dart"}),")"]}),"\n",(0,a.jsx)(n.h3,{id:"1-background-service-initialization-callback",children:"1. Background Service Initialization Callback"}),"\n",(0,a.jsx)(n.p,{children:"This function runs in the separate background isolate."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"// ... imports ...\nimport 'package:example/database/database_native.dart'\n    if (dart.library.html) 'package:example/database/database_web.dart'\n    as platform_db; // Conditional import for platform-specific DB setup\n\n@pragma('vm:entry-point')\nFuture<void> _myAppBackgroundInitialization(ServiceInstance service) async {\n  WidgetsFlutterBinding.ensureInitialized();\n  DartPluginRegistrant.ensureInitialized(); // Important for platform channels\n\n  print(\"BackgroundService: MyAppBackgroundInitialization - Starting...\");\n\n  try {\n    // Initialize database FOR THIS ISOLATE\n    final appDb = platform_db.getDatabase();\n    await appDb.initialize();\n    final SqliteConnection backgroundDbConnection = appDb.db as SqliteConnection;\n    \n    // Set the database connection for the BackgroundService static methods\n    BackgroundService.setBackgroundDbConnection(backgroundDbConnection);\n    print(\"BackgroundService: MyAppBackgroundInitialization - Background DB connection set.\");\n\n    // Register your job handlers\n    BackgroundService.registerJobHandler('dummyTask', _dummyJobHandler);\n    // BackgroundService.registerJobHandler('sendEmail', _sendEmailHandler);\n    // BackgroundService.registerJobHandler('processImage', _processImageHandler);\n    print(\"BackgroundService: MyAppBackgroundInitialization - Job handlers registered.\");\n\n  } catch (e, s) {\n    print(\"BackgroundService: MyAppBackgroundInitialization - CRITICAL ERROR: $e\\n$s\");\n    service.stopSelf(); // Stop service if critical setup fails\n    return;\n  }\n  print(\"BackgroundService: MyAppBackgroundInitialization - Complete.\");\n}\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"2-initialize-backgroundservice-in-main",children:["2. Initialize ",(0,a.jsx)(n.code,{children:"BackgroundService"})," in ",(0,a.jsx)(n.code,{children:"main()"})]}),"\n",(0,a.jsxs)(n.p,{children:["Call ",(0,a.jsx)(n.code,{children:"BackgroundService.initialize"})," from your main isolate's ",(0,a.jsx)(n.code,{children:"main"})," function."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:'// filepath: example/frontend/lib/main.dart\n\nFuture<void> main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n\n  // Initialize other services (e.g., Supabase)\n  // await Supabase.initialize(...);\n\n  // Initialize Background Service\n  await BackgroundService.initialize(\n    appInitializationCallback: _myAppBackgroundInitialization,\n    initialNotificationTitle: "My App Service", // Android notification\n    initialNotificationContent: "Performing background tasks...", // Android notification\n    // Optional: notificationIconName: \'ic_my_app_notification\',\n  );\n  print("Main Isolate: BackgroundService Configured.");\n\n  // ... (ensure default preferences, etc.) ...\n\n  runApp(const ProviderScope(child: MyApp()));\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"job-management",children:"Job Management"}),"\n",(0,a.jsx)(n.h3,{id:"1-defining-job-handlers",children:"1. Defining Job Handlers"}),"\n",(0,a.jsxs)(n.p,{children:["Job handlers are asynchronous functions that perform the actual work. They\nreceive the ",(0,a.jsx)(n.code,{children:"ServiceInstance"}),", an optional ",(0,a.jsx)(n.code,{children:"payload"}),", and the background\nisolate's ",(0,a.jsx)(n.code,{children:"SqliteConnection"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:'@pragma(\'vm:entry-point\')\nFuture<void> _dummyJobHandler(\n  ServiceInstance service,\n  Map<String, dynamic>? payload,\n  SqliteConnection db, // Background isolate\'s DB connection\n) async {\n  print("BackgroundService: DummyJobHandler - Started with payload: $payload");\n  final message = payload?[\'message\'] ?? \'No message\';\n\n  // Simulate work\n  for (int i = 0; i < 5; i++) {\n    await Future.delayed(const Duration(seconds: 3));\n    print("BackgroundService: DummyJobHandler - Working... ($message, step ${i+1})");\n    // Optionally update Android foreground notification\n    if (service is AndroidServiceInstance && await service.isForegroundService()) {\n      service.setForegroundNotificationInfo(\n        title: "Dummy Task Progress",\n        content: "Processing: $message (Step ${i+1}/5)",\n      );\n    }\n  }\n\n  print("BackgroundService: DummyJobHandler - Finished.");\n\n  if (service is AndroidServiceInstance && await service.isForegroundService()) {\n    service.setForegroundNotificationInfo(\n      title: "Dummy Task Completed",\n      content: "Finished processing: $message",\n    );\n    // Revert to default notification after a delay\n    Future.delayed(const Duration(seconds: 10), () {\n      service.setForegroundNotificationInfo(\n        title: "My App Service", // Initial title\n        content: "Performing background tasks...", // Initial content\n      );\n    });\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-enqueuing-jobs-from-the-ui",children:"2. Enqueuing Jobs from the UI"}),"\n",(0,a.jsxs)(n.p,{children:["Use ",(0,a.jsx)(n.code,{children:"BackgroundService.job()"})," from your UI isolate to add a job to the queue.\nYou must provide the UI isolate's ",(0,a.jsx)(n.code,{children:"SqliteConnection"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"// filepath: example/frontend/lib/ui/tabs/background_tab.dart (Example Usage)\n\nFuture<void> _enqueueDummyTask() async {\n  // ... (setState for loading state) ...\n  try {\n    // Get the UI isolate's database connection via Riverpod\n    final appDb = await ref.read(databaseProvider.future);\n    final uiDbConnection = appDb.db as SqliteConnection;\n\n    final jobId = await BackgroundService.job(\n      db: uiDbConnection, // UI isolate's DB connection\n      jobKey: 'dummyTask', // Must match a registered handler\n      payload: {'message': 'Hello from UI at ${DateTime.now()}'},\n      priority: 1, // Optional priority\n      maxAttempts: 3, // Optional max attempts\n    );\n\n    if (mounted) {\n      if (jobId != null) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text('Dummy task enqueued with ID: $jobId')),\n        );\n      } else {\n        // Handle enqueue failure (e.g., handler not registered if service just restarted)\n      }\n    }\n  } catch (e) {\n    // Handle error\n  } finally {\n    // ... (setState to stop loading state) ...\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"3-backgroundjobmanager-ui-isolate",children:["3. ",(0,a.jsx)(n.code,{children:"BackgroundJobManager"})," (UI Isolate)"]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"BackgroundJobManager"})," allows the UI to query and manage jobs from the\n",(0,a.jsx)(n.code,{children:"background_service_jobs"})," table."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Provider Setup:"})," Your ",(0,a.jsx)(n.code,{children:"background_job_manager_provider.g.dart"})," (or manually\ncreated provider) should look like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"// filepath: example/frontend/lib/database/providers/background_job_manager_provider.g.dart\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:sqlite_async/sqlite_async.dart';\nimport 'package:tether_libs/background_service/background_service_manager.dart';\nimport '../database.dart'; // Your main database provider\n\nfinal backgroundJobManagerProvider = Provider<BackgroundJobManager>((ref) {\n  final appDatabase = ref.watch(databaseProvider).requireValue;\n  final dbConnection = appDatabase.db as SqliteConnection; // UI's DB connection\n  return BackgroundJobManager(db: dbConnection);\n});\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Usage:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"// Accessing the manager in a widget\nfinal jobManager = ref.watch(backgroundJobManagerProvider);\n\n// Get a job by ID\nfinal job = await jobManager.getJobById(someJobId);\n\n// Get pending jobs\nfinal pendingJobs = await jobManager.getJobsByStatus(BackgroundJobStatus.pending);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"ui-integration--status-monitoring",children:"UI Integration & Status Monitoring"}),"\n",(0,a.jsx)(n.h3,{id:"controlling-the-service",children:"Controlling the Service"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"BackgroundServiceTab"})," in the example demonstrates how to start, stop, and\ncheck the status of the service:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"// Start the service\nawait BackgroundService.start();\n\n// Stop the service\nawait BackgroundService.stop();\n\n// Check if running\nfinal bool isRunning = await BackgroundService.isRunning();\n"})}),"\n",(0,a.jsx)(n.h3,{id:"displaying-job-status",children:"Displaying Job Status"}),"\n",(0,a.jsx)(n.p,{children:"Create Riverpod providers to stream job status updates:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"// Provider to watch jobs by status (e.g., pending)\nfinal pendingJobsStreamProvider = StreamProvider<List<BackgroundJob>>((ref) async* {\n  final manager = ref.watch(backgroundJobManagerProvider);\n  while (true) {\n    // Periodically poll for updates or use a more sophisticated notification mechanism\n    // if your database supports it (e.g., SQLite update hooks via FFI).\n    // For simplicity, this example polls.\n    yield await manager.getJobsByStatus(BackgroundJobStatus.pending, orderByCreation: 'DESC');\n    await Future.delayed(const Duration(seconds: 5)); // Poll interval\n  }\n});\n\n// Provider to watch a specific job by ID\nfinal jobStreamProvider = StreamProvider.family<BackgroundJob?, int>((ref, jobId) async* {\n  final manager = ref.watch(backgroundJobManagerProvider);\n  while (true) {\n    yield await manager.getJobById(jobId);\n    await Future.delayed(const Duration(seconds: 2));\n  }\n});\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Widget Example:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"class JobStatusDashboard extends ConsumerWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final pendingJobsAsync = ref.watch(pendingJobsStreamProvider);\n\n    return pendingJobsAsync.when(\n      data: (jobs) => jobs.isEmpty\n          ? Center(child: Text('No pending jobs'))\n          : ListView.builder(\n              itemCount: jobs.length,\n              itemBuilder: (context, index) {\n                final job = jobs[index];\n                return ListTile(\n                  title: Text('${job.jobKey} (ID: ${job.id})'),\n                  subtitle: Text('Status: ${job.status.name}, Attempts: ${job.attempts}'),\n                  // ... more details\n                );\n              },\n            ),\n      loading: () => Center(child: CircularProgressIndicator()),\n      error: (err, stack) => Center(child: Text('Error: $err')),\n    );\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"using-providercontainer-for-non-widget-scenarios-main-isolate",children:["Using ",(0,a.jsx)(n.code,{children:"ProviderContainer"})," for Non-Widget Scenarios (Main Isolate)"]}),"\n",(0,a.jsxs)(n.p,{children:["Sometimes you need to interact with Riverpod providers (like ",(0,a.jsx)(n.code,{children:"databaseProvider"}),"\nto get a ",(0,a.jsx)(n.code,{children:"SqliteConnection"})," or ",(0,a.jsx)(n.code,{children:"backgroundJobManagerProvider"}),") outside the\nwidget tree in your ",(0,a.jsx)(n.strong,{children:"main UI isolate"}),", for example, in a service class, a\nutility function, or for testing. ",(0,a.jsx)(n.code,{children:"ProviderContainer"})," is the solution for these\nmain-isolate scenarios."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Important:"})," You are responsible for disposing the ",(0,a.jsx)(n.code,{children:"ProviderContainer"})," when\nit's no longer needed to prevent memory leaks."]}),"\n",(0,a.jsx)(n.h3,{id:"example-1-enqueuing-a-job-from-a-service-class-main-isolate",children:"Example 1: Enqueuing a Job from a Service Class (Main Isolate)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"// This service class runs in the main UI isolate\nclass MyBackgroundJobEnqueueService {\n  final ProviderContainer _container; // Typically, this container would be passed in or be a long-lived one\n\n  MyBackgroundJobEnqueueService(this._container);\n\n  Future<void> scheduleReportGeneration(String reportType) async {\n    try {\n      // 1. Obtain the UI isolate's database connection from the main container\n      final appDatabase = await _container.read(databaseProvider.future);\n      final SqliteConnection uiDbConnection = appDatabase.db as SqliteConnection;\n\n      // 2. Enqueue the job\n      final jobId = await BackgroundService.job(\n        db: uiDbConnection,\n        jobKey: 'generateReport', // Ensure this handler is registered\n        payload: {'reportType': reportType, 'requestedBy': 'main_isolate_service'},\n      );\n      print('Report generation job enqueued from Main Isolate Service with ID: $jobId');\n    } catch (e) {\n      print('Error in MyBackgroundJobEnqueueService enqueuing job: $e');\n    }\n  }\n  // Dispose method might be needed if the container is scoped to this service\n}\n\n// Usage (e.g., during app setup or from another main isolate service):\n// final mainGlobalContainer = ProviderContainer(); // A longer-lived container\n// final jobEnqueueService = MyBackgroundJobEnqueueService(mainGlobalContainer);\n// await jobEnqueueService.scheduleReportGeneration('dailySummary');\n// Later, when appropriate: mainGlobalContainer.dispose();\n"})}),"\n",(0,a.jsx)(n.h3,{id:"example-2-reading-job-status-for-utilities-main-isolate",children:"Example 2: Reading Job Status for Utilities (Main Isolate)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"// This utility function runs in the main UI isolate\nFuture<void> checkJobStatusUtility(int jobId) async {\n  final container = ProviderContainer(); // Create a temporary container for this utility\n  try {\n    final jobManager = container.read(backgroundJobManagerProvider);\n    final BackgroundJob? job = await jobManager.getJobById(jobId);\n\n    if (job != null) {\n      print('Job $jobId Status (from Main Isolate Utility): ${job.status}, Attempts: ${job.attempts}');\n    } else {\n      print('Job $jobId not found (from Main Isolate Utility).');\n    }\n  } catch (e) {\n    print('Error checking job status in Main Isolate Utility: $e');\n  } finally {\n    container.dispose(); // Dispose the temporary container\n  }\n}\n\n// Usage:\n// await checkJobStatusUtility(123);\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"using-providercontainer-within-a-job-handler-background-isolate",children:["Using ",(0,a.jsx)(n.code,{children:"ProviderContainer"})," within a Job Handler (Background Isolate)"]}),"\n",(0,a.jsxs)(n.p,{children:["If a background job handler itself has complex internal logic or needs to manage\nits own set of dependencies, you can create and use a ",(0,a.jsx)(n.code,{children:"ProviderContainer"}),"\n",(0,a.jsx)(n.em,{children:"within that job handler"}),". This container will be ",(0,a.jsx)(n.strong,{children:"local to the background\nisolate and that specific job's execution"}),"; it is ",(0,a.jsx)(n.strong,{children:"not"})," connected to your\nmain UI isolate's ",(0,a.jsx)(n.code,{children:"ProviderContainer"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"This pattern is useful for organizing code within the job handler, especially if\nit calls multiple services or performs several distinct steps."}),"\n",(0,a.jsxs)(n.h3,{id:"example-job-handler-with-its-own-local-providercontainer",children:["Example: Job Handler with its Own Local ",(0,a.jsx)(n.code,{children:"ProviderContainer"})]}),"\n",(0,a.jsxs)(n.p,{children:["Let's imagine a job handler that needs to fetch data using a service and then\nprocess it using another service, both of which might benefit from being managed\nby Riverpod ",(0,a.jsx)(n.em,{children:"within the job's scope"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"// Define services that might be used by the job handler.\n// These would typically be in their own files.\nclass DataFetcherService {\n  final SqliteConnection _db;\n  DataFetcherService(this._db);\n\n  Future<List<Map<String, dynamic>>> fetchData(String queryKey) async {\n    print(\"BackgroundJob/DataFetcherService: Fetching data for '$queryKey' using ${_db.hashCode}\");\n    // Simulate DB query using the background isolate's DB connection\n    await Future.delayed(const Duration(milliseconds: 500));\n    return [{'id': 1, 'data': 'Sample data for $queryKey'}];\n  }\n}\n\nclass DataProcessorService {\n  Future<Map<String, dynamic>> process(List<Map<String, dynamic>> rawData) async {\n    print(\"BackgroundJob/DataProcessorService: Processing ${rawData.length} items.\");\n    await Future.delayed(const Duration(milliseconds: 300));\n    return {'processed_count': rawData.length, 'summary': 'Processed successfully'};\n  }\n}\n\n// Define providers for these services, intended for the job's local container\nfinal dataFetcherProvider = Provider<DataFetcherService>((ref) {\n  // This provider would need access to the SqliteConnection.\n  // For this example, we'll assume it's made available to the container\n  // or the service is constructed directly with it.\n  // This is a simplified example; in reality, you'd pass the 'db' from the handler.\n  throw UnimplementedError(\"dataFetcherProvider needs db. Override or pass directly.\");\n});\n\nfinal dataProcessorProvider = Provider<DataProcessorService>((ref) {\n  return DataProcessorService();\n});\n\n\n// The job handler itself\n@pragma('vm:entry-point')\nFuture<void> _complexDataProcessingJobHandler(\n  ServiceInstance service,\n  Map<String, dynamic>? payload,\n  SqliteConnection db, // This is the background isolate's DB connection\n) async {\n  final queryKey = payload?['queryKey'] as String?;\n  if (queryKey == null) {\n    throw ArgumentError(\"queryKey is required in payload for complexDataProcessingJobHandler.\");\n  }\n\n  print(\"BackgroundJob/ComplexHandler: Started for queryKey '$queryKey'. DB: ${db.hashCode}\");\n\n  // Create a ProviderContainer local to this job's execution\n  final jobContainer = ProviderContainer(\n    overrides: [\n      // Override dataFetcherProvider to use the 'db' connection passed to the handler\n      dataFetcherProvider.overrideWithValue(DataFetcherService(db)),\n    ]\n  );\n\n  try {\n    // Access services through the local container\n    final fetcher = jobContainer.read(dataFetcherProvider);\n    final processor = jobContainer.read(dataProcessorProvider);\n\n    final rawData = await fetcher.fetchData(queryKey);\n    final processedResult = await processor.process(rawData);\n\n    print(\"BackgroundJob/ComplexHandler: Successfully processed data for '$queryKey'. Result: $processedResult\");\n\n    // Example: Store result or update status using the 'db' connection\n    await db.execute(\n        \"INSERT INTO job_results (job_key, query_key, result, processed_at) VALUES (?, ?, ?, ?)\",\n        ['complexDataProcessing', queryKey, jsonEncode(processedResult), DateTime.now().toIso8601String()]\n    );\n\n  } catch (e, s) {\n    print(\"BackgroundJob/ComplexHandler: Error processing data for '$queryKey': $e\\n$s\");\n    throw e; // Re-throw to allow BackgroundService to handle failure/retry\n  } finally {\n    jobContainer.dispose(); // Crucial: Dispose the local container\n    print(\"BackgroundJob/ComplexHandler: Finished for queryKey '$queryKey'.\");\n  }\n}\n\n// Remember to register this handler in _myAppBackgroundInitialization:\n// BackgroundService.registerJobHandler('complexDataProcessing', _complexDataProcessingJobHandler);\n\n// And to enqueue it from the UI isolate:\n// await BackgroundService.job(\n//   db: uiDbConnection,\n//   jobKey: 'complexDataProcessing',\n//   payload: {'queryKey': 'userActivity'},\n// );\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.strong,{children:["Key points for using ",(0,a.jsx)(n.code,{children:"ProviderContainer"})," inside a job handler:"]})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Isolation"}),": The ",(0,a.jsx)(n.code,{children:"jobContainer"})," is entirely separate from your UI's main\n",(0,a.jsx)(n.code,{children:"ProviderContainer"}),". It cannot access providers or states from the UI isolate."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Dependency Injection"}),": It's useful for managing dependencies ",(0,a.jsx)(n.em,{children:"within"})," the\ncomplex logic of a single job handler."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Database Connection"}),": The background isolate's ",(0,a.jsx)(n.code,{children:"SqliteConnection"})," (",(0,a.jsx)(n.code,{children:"db"}),"\nparameter to the handler) should be passed to any services within this local\ncontainer that need database access. This can be done via constructor\ninjection or by overriding providers as shown."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Lifecycle"}),": Create the ",(0,a.jsx)(n.code,{children:"jobContainer"})," at the beginning of the handler and\n",(0,a.jsxs)(n.strong,{children:["always ",(0,a.jsx)(n.code,{children:"dispose()"})," it in a ",(0,a.jsx)(n.code,{children:"finally"})," block"]})," to prevent resource leaks\nwithin the background isolate."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Simplicity"}),": For simpler job handlers, creating a local ",(0,a.jsx)(n.code,{children:"ProviderContainer"}),"\nmight be overkill. Direct instantiation of necessary helper classes might be\nmore straightforward."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.strong,{children:["Note on ",(0,a.jsx)(n.code,{children:"ProviderContainer"})," Lifecycle (General):"]})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["If you create a ",(0,a.jsx)(n.code,{children:"ProviderContainer"})," for a short-lived operation (like a single\nfunction call, a test, or within a job handler), dispose it in a ",(0,a.jsx)(n.code,{children:"finally"}),"\nblock."]}),"\n",(0,a.jsxs)(n.li,{children:["If a service class in the main isolate uses a ",(0,a.jsx)(n.code,{children:"ProviderContainer"}),", the\ncontainer might be passed in or created by the service. Its disposal should\nalign with the service's lifecycle."]}),"\n",(0,a.jsxs)(n.li,{children:["Avoid creating many short-lived containers frequently in performance-critical\npaths. For UI, always use ",(0,a.jsx)(n.code,{children:"ConsumerWidget"}),", ",(0,a.jsx)(n.code,{children:"ConsumerStatefulWidget"}),", or ",(0,a.jsx)(n.code,{children:"ref"}),"\nfrom hooks."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"error-handling--retries",children:"Error Handling & Retries"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Job Handlers"}),": If a job handler throws an exception, the\n",(0,a.jsx)(n.code,{children:"BackgroundService"})," catches it, marks the job as ",(0,a.jsx)(n.code,{children:"FAILED"})," in the database, and\nrecords the error message in ",(0,a.jsx)(n.code,{children:"last_error"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Retries"}),": The service automatically attempts to retry failed jobs up to\n",(0,a.jsx)(n.code,{children:"max_attempts"})," times. The ",(0,a.jsx)(n.code,{children:"attempts"})," count is incremented."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"No Retry"}),": If an error is considered non-recoverable, the job handler can\ncatch it and simply return without re-throwing, or throw a specific exception\ntype that your ",(0,a.jsx)(n.code,{children:"BackgroundService"})," modification might handle to prevent\nretries."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Idempotent Jobs"}),": Design job handlers to be idempotent where possible,\nmeaning running them multiple times with the same input produces the same\nresult without unintended side effects."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Granular Jobs"}),": Break down complex tasks into smaller, manageable jobs."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Payloads"}),": Keep payloads concise and include all necessary information for\nthe job to execute independently."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Error Reporting"}),": Implement robust error logging within job handlers and\nconsider reporting critical failures to an external monitoring service."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Resource Management"}),": Ensure job handlers clean up any resources they use\n(e.g., temporary files)."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Background DB Connection"}),": Always use the ",(0,a.jsx)(n.code,{children:"SqliteConnection"})," provided to\nthe job handler for database operations within the background isolate. The UI\nisolate uses its own connection (typically via ",(0,a.jsx)(n.code,{children:"databaseProvider"}),")."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Testing"}),": Thoroughly test job handlers and the overall background\nprocessing flow."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This documentation provides a comprehensive guide to using the Background\nService unit in your Flutter Tether application, leveraging its persistence,\nbackground execution"})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);