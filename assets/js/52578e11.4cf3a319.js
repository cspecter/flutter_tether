"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[137],{1970:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"additional_features/feed_provider","title":"Feed Management System","description":"Tether includes an optional, powerful Feed Management System designed to","source":"@site/docs/additional_features/feed_provider.md","sourceDirName":"additional_features","slug":"/additional_features/feed_provider","permalink":"/flutter_tether/additional_features/feed_provider","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Additional Features","permalink":"/flutter_tether/category/additional-features"},"next":{"title":"Auth Manager","permalink":"/flutter_tether/additional_features/auth_manager"}}');var i=t(4848),o=t(8453);const s={sidebar_position:1},a="Feed Management System",l={},d=[{value:"Core Concepts",id:"core-concepts",level:2},{value:"Count Tracking and Pagination",id:"count-tracking-and-pagination",level:2},{value:"Setting up a Regular Feed",id:"setting-up-a-regular-feed",level:2},{value:"1. Define <code>FeedStreamNotifierSettings</code>",id:"1-define-feedstreamnotifiersettings",level:3},{value:"2. Use in a Widget with Count Tracking",id:"2-use-in-a-widget-with-count-tracking",level:3},{value:"Setting up a Search Feed",id:"setting-up-a-search-feed",level:2},{value:"1. Define <code>FeedStreamNotifierSettings</code>",id:"1-define-feedstreamnotifiersettings-1",level:3},{value:"2. Use in a Widget with Search and Count Tracking",id:"2-use-in-a-widget-with-search-and-count-tracking",level:3},{value:"Key Features &amp; Usage Notes",id:"key-features--usage-notes",level:2},{value:"Count Tracking Best Practices",id:"count-tracking-best-practices",level:2}];function c(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"feed-management-system",children:"Feed Management System"})}),"\n",(0,i.jsxs)(n.p,{children:["Tether includes an optional, powerful Feed Management System designed to\nsimplify the creation and management of paginated content feeds within your\nFlutter application. This system leverages a Tether-managed local SQLite table\n(",(0,i.jsx)(n.code,{children:"feed_item_references"}),") to store the order and references of feed items,\ncombined with a Riverpod ",(0,i.jsx)(n.code,{children:"StreamNotifier"})," for reactive UI updates. The system\nnow includes intelligent count tracking to prevent unnecessary API calls and\nprovide better pagination controls."]}),"\n",(0,i.jsxs)(n.p,{children:["Note: This feature requires ",(0,i.jsx)(n.code,{children:"Riverpod"})," to work."]}),"\n",(0,i.jsx)(n.p,{children:"It supports both regular, filterable feeds and feeds driven by full-text search."}),"\n",(0,i.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,i.jsx)(n.p,{children:"At the heart of the feed system are two main classes:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"FeedStreamNotifierSettings<TModel>"})}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A configuration object that defines the behavior and data source for a\nspecific feed."}),"\n",(0,i.jsxs)(n.li,{children:["It's crucial that instances of these settings are stable (e.g., defined as\n",(0,i.jsx)(n.code,{children:"Provider"})," or ",(0,i.jsx)(n.code,{children:"final"})," constants) if their parameters don't change, or\nrecreated when parameters ",(0,i.jsx)(n.em,{children:"do"})," change, to ensure Riverpod correctly manages\nnotifier instances. For example, if you have a feed that is filtered by\ngenre, you should create a new instance of ",(0,i.jsx)(n.code,{children:"FeedStreamNotifierSettings"}),"\nwhenever the selected genre changes. This needs to propagate through to the\n",(0,i.jsx)(n.code,{children:"FeedStreamNotifier"})," instances that use these updated settings."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Key Properties"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"feedKey"}),": A unique ",(0,i.jsx)(n.code,{children:"String"})," identifier for the feed. This key is used to\nstore and retrieve feed item references from the local database. Usually\nthis will be per Widget, for example ",(0,i.jsx)(n.code,{children:"books_feed_filtered"})," or\n",(0,i.jsx)(n.code,{children:"books_search_feed"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"clientManager"}),": The ",(0,i.jsx)(n.code,{children:"ClientManager<TModel>"})," instance for the data type\nof the feed items."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"selectArgs"}),": A ",(0,i.jsx)(n.code,{children:"SupabaseSelectBuilderBase"})," instance defining which\ncolumns and relationships to fetch for each item. This should generally\nbe a stable instance."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"fromJsonFactory"}),": The factory method (e.g., ",(0,i.jsx)(n.code,{children:"YourModel.fromJson"}),") to\nconvert JSON data into your ",(0,i.jsx)(n.code,{children:"TModel"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pageSize"}),": The number of items to fetch per page (defaults to 20)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"queryCustomizer"}),": An optional function\n",(0,i.jsx)(n.code,{children:"ClientManagerFilterBuilder<TModel> Function(ClientManagerFilterBuilder<TModel> baseQuery)"}),"\nthat allows you to apply filters or modifications to the base query for\nthe feed. This is useful for creating feeds filtered by a category,\nstatus, etc. To reset the filters you can pass null to this function."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"searchColumn"}),": An optional ",(0,i.jsx)(n.code,{children:"TetherColumn"})," used specifically for search\nfeeds, indicating which column (typically a ",(0,i.jsx)(n.code,{children:"tsvector"})," column) to perform\nfull-text search against."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"FeedStreamNotifier<TModel>"})}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.code,{children:"FamilyStreamNotifier"})," (from Riverpod) that manages the state of a feed\nbased on the provided ",(0,i.jsx)(n.code,{children:"FeedStreamNotifierSettings"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["It handles:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Fetching initial data with count tracking."}),"\n",(0,i.jsx)(n.li,{children:"Fetching subsequent pages (pagination) only when more items are\navailable."}),"\n",(0,i.jsx)(n.li,{children:"Applying search terms (if configured)."}),"\n",(0,i.jsx)(n.li,{children:"Applying dynamic filters."}),"\n",(0,i.jsxs)(n.li,{children:["Storing item references and their order in the local\n",(0,i.jsx)(n.code,{children:"feed_item_references"})," table."]}),"\n",(0,i.jsxs)(n.li,{children:["Streaming the ordered list of ",(0,i.jsx)(n.code,{children:"TModel"})," items to the UI."]}),"\n",(0,i.jsx)(n.li,{children:"Tracking total remote count to prevent unnecessary API calls."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The system works by first fetching item data from your Supabase backend based on\nthe configuration. The ",(0,i.jsx)(n.code,{children:"TetherClientReturn<TModel>"})," response includes both the\ndata and the total count of matching records. These references are stored\nlocally, and the count is tracked to enable intelligent pagination. The\n",(0,i.jsx)(n.code,{children:"FeedStreamNotifier"})," then watches this local table and provides a reactive\nstream of ",(0,i.jsx)(n.code,{children:"List<TModel>"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"count-tracking-and-pagination",children:"Count Tracking and Pagination"}),"\n",(0,i.jsx)(n.p,{children:"The feed system now includes intelligent count tracking:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Total Count"}),": The ",(0,i.jsx)(n.code,{children:"totalRemoteCount"})," tracks the total number of items\navailable from the remote source"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Smart Pagination"}),": The ",(0,i.jsx)(n.code,{children:"fetchMoreItems()"})," method only makes API calls when\nmore items are actually available"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Efficient Loading"}),": Prevents unnecessary network requests when all items\nhave been loaded"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"UI Integration"}),": Exposes ",(0,i.jsx)(n.code,{children:"hasMoreItems"})," property for controlling load more\nbuttons and pagination UI"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"setting-up-a-regular-feed",children:"Setting up a Regular Feed"}),"\n",(0,i.jsx)(n.p,{children:'A "regular" feed is typically a list of items that can be paginated and\npotentially filtered based on criteria other than full-text search (e.g., by\ncategory, date, etc.).'}),"\n",(0,i.jsxs)(n.h3,{id:"1-define-feedstreamnotifiersettings",children:["1. Define ",(0,i.jsx)(n.code,{children:"FeedStreamNotifierSettings"})]}),"\n",(0,i.jsx)(n.p,{children:"Create a provider or a stable instance for your feed settings."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"// Provider to manage the selected genre ID.\nfinal selectedGenreIdProvider = NotifierProvider<StringNotifier, String?>(\n  StringNotifier.new,\n); // Starts as null, can be set to a genre ID.\n\n// Provider for the FeedStreamNotifierSettings\nfinal bookFeedProvider = Provider<FeedStreamNotifierSettings<BookModel>>((ref) {\n  final bookClientManager = ref.watch(booksManagerProvider);\n  final selectedGenreId = ref.watch(selectedGenreIdProvider);\n\n  // queryCustomizer will be re-evaluated if selectedGenreId changes\n  ClientManagerFilterBuilder<BookModel> queryCustomizer(\n    ClientManagerFilterBuilder<BookModel> baseQuery,\n  ) {\n    if (selectedGenreId == null) {\n      return baseQuery; // No genre filter\n    }\n    // IMPORTANT: When filtering on a many-to-many relationship like genres via a join table (book_genres),\n    // ensure your selectArgs in `bookSelect` includes the necessary join\n    // (e.g., BooksSelectBuilder().select().withBookGenres(BookGenresSelectBuilder().select()))\n    // and then filter on the column from the join table or the target table.\n    return baseQuery.eq(BookGenresColumn.genreId, selectedGenreId); // Assuming BookGenresColumn.genreId exists\n  }\n\n  return FeedStreamNotifierSettings<BookModel>(\n    feedKey: 'books_feed_by_genre', // Unique key for this feed\n    clientManager: bookClientManager,\n    selectArgs: bookSelect, // Your predefined SupabaseSelectBuilderBase instance\n    fromJsonFactory: BookModel.fromJson,\n    pageSize: 20,\n    queryCustomizer: queryCustomizer,\n  );\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-use-in-a-widget-with-count-tracking",children:"2. Use in a Widget with Count Tracking"}),"\n",(0,i.jsx)(n.p,{children:"Consume the provider in your widget to display the feed and handle interactions\nwith intelligent pagination."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"class FeedTab extends ConsumerStatefulWidget {\n  // ...\n}\n\nclass _FeedTabState extends ConsumerState<FeedTab> {\n  final ScrollController _scrollController = ScrollController();\n  bool _isFetchingMore = false;\n\n  @override\n  void initState() {\n    super.initState();\n    _scrollController.addListener(_scrollListener);\n  }\n\n  void _scrollListener() {\n    if (_scrollController.position.pixels >= \n        _scrollController.position.maxScrollExtent - 200) {\n      _fetchMore();\n    }\n  }\n\n  Future<void> _fetchMore() async {\n    if (_isFetchingMore) return;\n    \n    final settings = ref.read(bookFeedProvider);\n    final notifier = ref.read(booksFeedProvider(settings).notifier);\n    \n    // Check if there are more items before attempting to fetch\n    if (!notifier.hasMoreItems) {\n      print('No more items to load');\n      return;\n    }\n\n    setState(() => _isFetchingMore = true);\n    await notifier.fetchMoreItems();\n\n    if (mounted) {\n      setState(() => _isFetchingMore = false);\n    }\n  }\n\n  void _updateSelectedGenre(String? genreId) {\n    ref.read(selectedGenreIdProvider.notifier).set(genreId);\n    // When selectedGenreIdProvider changes, bookFeedProvider will re-evaluate,\n    // providing new settings to booksFeedProvider. This causes Riverpod\n    // to potentially create a new notifier instance or rebuild the existing one\n    // with the new settings, triggering a refresh of the feed.\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final settings = ref.watch(bookFeedProvider); // Watch for settings changes\n    final booksAsyncValue = ref.watch(booksFeedProvider(settings)); // Watch the feed data\n    final notifier = ref.read(booksFeedProvider(settings).notifier);\n\n    return booksAsyncValue.when(\n      data: (books) => Column(\n        children: [\n          // Count information display\n          if (notifier.totalRemoteCount != null)\n            Padding(\n              padding: const EdgeInsets.all(8.0),\n              child: Text(\n                'Showing ${books.length} of ${notifier.totalRemoteCount} books',\n                style: Theme.of(context).textTheme.bodySmall,\n              ),\n            ),\n          \n          // Genre selection chips\n          // ... genre selection UI ...\n          \n          // Books list\n          Expanded(\n            child: ListView.builder(\n              controller: _scrollController,\n              itemCount: books.length + (notifier.hasMoreItems ? 1 : 0),\n              itemBuilder: (context, index) {\n                if (index == books.length) {\n                  // Load more indicator - only shown if more items available\n                  return _isFetchingMore\n                      ? const Center(child: CircularProgressIndicator())\n                      : TextButton(\n                          onPressed: _fetchMore,\n                          child: const Text('Load More'),\n                        );\n                }\n                \n                final book = books[index];\n                return ListTile(\n                  title: Text(book.title),\n                  subtitle: Text(book.author?.name ?? 'Unknown Author'),\n                  // ... other book details\n                );\n              },\n            ),\n          ),\n        ],\n      ),\n      loading: () => const Center(child: CircularProgressIndicator()),\n      error: (error, stack) => Center(child: Text('Error: $error')),\n    );\n  }\n\n  @override\n  void dispose() {\n    _scrollController.dispose();\n    super.dispose();\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"setting-up-a-search-feed",children:"Setting up a Search Feed"}),"\n",(0,i.jsx)(n.p,{children:"A search feed allows users to input search terms, typically for full-text\nsearch. This assumes that full-text search is already set up in your Supabase\ndatabase. When set up properly full-text search is fast and can provide near\nreal-time results."}),"\n",(0,i.jsxs)(n.h3,{id:"1-define-feedstreamnotifiersettings-1",children:["1. Define ",(0,i.jsx)(n.code,{children:"FeedStreamNotifierSettings"})]}),"\n",(0,i.jsxs)(n.p,{children:["Configure settings specifically for search, including the ",(0,i.jsx)(n.code,{children:"searchColumn"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"final bookSearchSettingsProvider = Provider<FeedStreamNotifierSettings<BookModel>>((ref) {\n  final bookClientManager = ref.watch(booksManagerProvider);\n  return FeedStreamNotifierSettings<BookModel>(\n    feedKey: 'books_search_feed', // Unique key for this search feed\n    searchColumn: BooksColumn.tsvector, // The tsvector column for FTS\n    clientManager: bookClientManager,\n    selectArgs: bookSelect, // Your predefined SupabaseSelectBuilderBase instance\n    fromJsonFactory: BookModel.fromJson,\n    pageSize: 20,\n    // queryCustomizer can also be used here for base filters on the search, if needed\n  );\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-use-in-a-widget-with-search-and-count-tracking",children:"2. Use in a Widget with Search and Count Tracking"}),"\n",(0,i.jsxs)(n.p,{children:["Consume the provider and use the notifier's ",(0,i.jsx)(n.code,{children:"search()"})," method with intelligent\npagination."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"class SearchFeedTab extends ConsumerStatefulWidget {\n  // ...\n}\n\nclass _SearchFeedTabState extends ConsumerState<SearchFeedTab> {\n  final TextEditingController _searchController = TextEditingController();\n  final ScrollController _scrollController = ScrollController();\n  bool _isFetchingMore = false;\n\n  @override\n  void initState() {\n    super.initState();\n    _scrollController.addListener(_scrollListener);\n  }\n\n  void _scrollListener() {\n    if (_scrollController.position.pixels >= \n        _scrollController.position.maxScrollExtent - 200) {\n      _fetchMore();\n    }\n  }\n\n  Future<void> _fetchMore() async {\n    if (_isFetchingMore) return;\n\n    final settings = ref.read(bookSearchSettingsProvider);\n    final notifier = ref.read(booksFeedProvider(settings).notifier);\n    \n    // Check if there are more items before attempting to fetch\n    if (!notifier.hasMoreItems) {\n      return;\n    }\n\n    setState(() => _isFetchingMore = true);\n    await notifier.fetchMoreItems();\n\n    if (mounted) {\n      setState(() => _isFetchingMore = false);\n    }\n  }\n\n  void _performSearch() {\n    final searchTerm = _searchController.text;\n    final settings = ref.read(bookSearchSettingsProvider);\n    final notifier = ref.read(booksFeedProvider(settings).notifier);\n    notifier.search(searchTerm);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final settings = ref.watch(bookSearchSettingsProvider);\n    final asyncValue = ref.watch(booksFeedProvider(settings));\n    final notifier = ref.read(booksFeedProvider(settings).notifier);\n\n    return Column(\n      children: [\n        // Search input\n        Padding(\n          padding: const EdgeInsets.all(8.0),\n          child: TextField(\n            controller: _searchController,\n            decoration: InputDecoration(\n              hintText: 'Search books...',\n              suffixIcon: IconButton(\n                icon: const Icon(Icons.search),\n                onPressed: _performSearch,\n              ),\n            ),\n            onSubmitted: (_) => _performSearch(),\n          ),\n        ),\n        \n        // Results\n        Expanded(\n          child: asyncValue.when(\n            data: (books) => Column(\n              children: [\n                // Search results count\n                if (notifier.totalRemoteCount != null)\n                  Padding(\n                    padding: const EdgeInsets.all(8.0),\n                    child: Text(\n                      '${notifier.totalRemoteCount} results found',\n                      style: Theme.of(context).textTheme.bodySmall,\n                    ),\n                  ),\n                \n                // Results list\n                Expanded(\n                  child: ListView.builder(\n                    controller: _scrollController,\n                    itemCount: books.length + (notifier.hasMoreItems ? 1 : 0),\n                    itemBuilder: (context, index) {\n                      if (index == books.length) {\n                        // Load more indicator\n                        return _isFetchingMore\n                            ? const Center(child: CircularProgressIndicator())\n                            : notifier.hasMoreItems\n                                ? TextButton(\n                                    onPressed: _fetchMore,\n                                    child: const Text('Load More Results'),\n                                  )\n                                : const SizedBox.shrink();\n                      }\n                      \n                      final book = books[index];\n                      return ListTile(\n                        title: Text(book.title),\n                        subtitle: Text(book.author?.name ?? 'Unknown Author'),\n                        // ... other book details\n                      );\n                    },\n                  ),\n                ),\n              ],\n            ),\n            loading: () => const Center(child: CircularProgressIndicator()),\n            error: (error, stack) => Center(child: Text('Error: $error')),\n          ),\n        ),\n      ],\n    );\n  }\n\n  @override\n  void dispose() {\n    _searchController.dispose();\n    _scrollController.dispose();\n    super.dispose();\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"key-features--usage-notes",children:"Key Features & Usage Notes"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Local Caching of Feed Structure"}),": The ",(0,i.jsx)(n.code,{children:"feed_item_references"})," table stores\nthe ",(0,i.jsx)(n.code,{children:"feed_key"}),", the source table of the item, the item's ID, and its display\norder. This allows for persistent, ordered feeds. The actual item data is\nfetched based on these references and also benefits from the ",(0,i.jsx)(n.code,{children:"ClientManager"}),"'s\nlocal caching of individual models."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Intelligent Count Tracking"}),": The system tracks the total number of\navailable items and prevents unnecessary API calls when all items have been\nloaded."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Smart Pagination"}),": The ",(0,i.jsx)(n.code,{children:"fetchMoreItems()"})," method only makes API calls when\nmore items are actually available, improving performance and user experience."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Count Information Access"}),": Use ",(0,i.jsx)(n.code,{children:"notifier.totalRemoteCount"})," to get the total\ncount and ",(0,i.jsx)(n.code,{children:"notifier.hasMoreItems"})," to check if more items are available."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"feedKey"})," Importance"]}),": Ensure each distinct feed in your application uses a\nunique ",(0,i.jsx)(n.code,{children:"feedKey"}),". This prevents data from different feeds from mixing in the\nlocal ",(0,i.jsx)(n.code,{children:"feed_item_references"})," table."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Riverpod Integration"}),": Designed for seamless use with Riverpod, leveraging\n",(0,i.jsx)(n.code,{children:"FamilyStreamNotifier"})," for state management and reactivity."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Query Customization"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"queryCustomizer"})," in ",(0,i.jsx)(n.code,{children:"FeedStreamNotifierSettings"})," allows defining a base set\nof filters for a feed."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Search"}),": The ",(0,i.jsx)(n.code,{children:"search(String terms)"})," method on the notifier triggers a new\nfetch based on the search terms against the configured ",(0,i.jsx)(n.code,{children:"searchColumn"}),". Count\ntracking is reset when search terms change."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reactivity"}),": Feeds automatically update if the underlying\n",(0,i.jsx)(n.code,{children:"FeedStreamNotifierSettings"})," change (when the provider for settings is\nre-evaluated) or when methods like ",(0,i.jsx)(n.code,{children:"search"}),", ",(0,i.jsx)(n.code,{children:"refreshFeed"}),", or\n",(0,i.jsx)(n.code,{children:"fetchMoreItems"})," are called."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Stable ",(0,i.jsx)(n.code,{children:"selectArgs"})," and ",(0,i.jsx)(n.code,{children:"fromJsonFactory"})]}),": These should ideally be static\nor top-level constants/functions to ensure stability for the\n",(0,i.jsx)(n.code,{children:"FeedStreamNotifierSettings"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Disposal"}),": The notifier handles its own disposal and stops processing if\nthe widget is unmounted, preventing errors."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Handling"}),": The ",(0,i.jsx)(n.code,{children:"AsyncValue"})," provided by Riverpod\n(",(0,i.jsx)(n.code,{children:"asyncValue.when(...)"}),") should be used to handle loading and error states."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"count-tracking-best-practices",children:"Count Tracking Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use Count Information"}),": Display the total count to users when available\nfor better UX"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Conditional Load More"}),': Only show "Load More" buttons when ',(0,i.jsx)(n.code,{children:"hasMoreItems"}),"\nis true"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Progress Indicators"}),": Use count information to show loading progress"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Search Results"}),": Display search result counts to help users understand the\nscope of results"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance"}),": The system prevents unnecessary API calls, but you should\nstill debounce search input for the best user experience"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var r=t(6540);const i={},o=r.createContext(i);function s(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);